<div align="center">

  <h1><code>Rust/wasm Chaotic Attractor Module</code></h1>

<strong>An Rust based innerloop module for my javascript chaotic attractor web app <a href="https:https://github.com/dmaynard/chaos-screen-saver">chaos-screen-saver</a>.</strong>

</div>

## About

This is a Rust Implementation of the same chaotic attractor implemented in javascript [here](https://github.com/dmaynard/attractor-iterator) .

The idea is to use the chaotic attractor as a kind of visual benchmark and let the user visualize the performance difference between the ES6 version and the Rust-wasm version, using their own browser on their own hardware.

## Pickover's Chaotic Attractor Iterator in Rust

Here is part of my latest software art project: An implementation in Rust, compiled to Web Assembly,  of Clifford A. Pickover's classic chaotic attractor. [Try it here](https://chaotic.netlify.com). Watch as a beautiful picture, one that no one has ever seen before, fades slowly into view.  This module was a result of refactoring the inner loop of the attractor into a module.  The parent Vue 2.0 app can now use either a Javascript or a WASM (from Rust) module to compute the next frame's pixels.

The image is generated by computing a histogram of the points visited in the image by continuously iterating a chaotic attractor in the browser's background.

Definition:

```
x = sin(b*y) - c sin(b*x)
y = sin(a*x) + d cos(a*y)
```

where a, b, c, d are the dour floating point variables that define each attractor.
For each new image the four variables are chosen at random. Next the point (x,y) is iterated to a new point (x, y). This point is then mapped into the image space to select a pixel. This pixel in the image is made one point darker on a scale of [255, 0] = [pure white, pure black]. The pixels are iterated continuously in this manner for a specified number of milliseconds, usually 15, or just less then one full animation frame. The module keeps track of how many total iterations have been completed, how many different pixels have been touched, and how many pixels have been completely blackened (RGB=0,0,0). This information is then used by the calling program to decide whether to continue iterating for another animation frame, or pause the iteration or to start iterating a new attractor.  This module is only concerned with calculating the pixel values for the next frame. Actual drawing of the image onto the screen is handled by the calling application and is done using a Javascript 2d canvas.


### üõ†Ô∏è Build with `wasm-pack build`

```
wasm-pack build --scope davidsmaynard
```

### üî¨ Test in Headless Browsers with `wasm-pack test`

```
wasm-pack test --headless --firefox
```

### üéÅ Publish to NPM with `wasm-pack publish`

```
wasm-pack publish --access=public
```

## üîã Batteries Included

- [`wasm-bindgen`]git fi(https://github.com/rustwasm/wasm-bindgen) for communicating
  between WebAssembly and JavaScript.
- [`console_error_panic_hook`](https://github.com/rustwasm/console_error_panic_hook)
  for logging panic messages to the developer console.
- [`wee_alloc`](https://github.com/rustwasm/wee_alloc), an allocator optimized
  for small code size.
```
